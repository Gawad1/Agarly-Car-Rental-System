var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/min-is/index.js
var require_min_is = __commonJS({
  "node_modules/min-is/index.js"(exports) {
    var is = exports;
    var obj = Object.prototype;
    global = global || {};
    var navigator = global.navigator;
    is.browser = function() {
      if (!is.wechatApp()) {
        if (navigator && global.window == global) {
          return true;
        }
      }
      return false;
    };
    is.h5 = function() {
      if (is.browser() && navigator.geolocation) {
        return true;
      }
      return false;
    };
    is.mobile = function() {
      if (is.browser() && /mobile/i.test(navigator.userAgent)) {
        return true;
      }
      return false;
    };
    is.wechatApp = function() {
      if ("object" == typeof wx) {
        if (wx && is.fn(wx.createVideoContext)) {
          return true;
        }
      }
      return false;
    };
    function _class(val) {
      var name = obj.toString.call(val);
      return name.substring(8, name.length - 1).toLowerCase();
    }
    function _type(val) {
      return typeof val;
    }
    function owns(owner, key) {
      return obj.hasOwnProperty.call(owner, key);
    }
    is._class = _class;
    is._type = _type;
    is.owns = owns;
    is.nan = function(val) {
      return val !== val;
    };
    is.bool = function(val) {
      return "boolean" == _class(val);
    };
    is.infinite = function(val) {
      return val == Infinity || val == -Infinity;
    };
    is.number = function(num) {
      return !isNaN(num) && "number" == _class(num);
    };
    is.iod = function(val) {
      if (is.number(val) && !is.infinite(val)) {
        return true;
      }
      return false;
    };
    is.decimal = function(val) {
      if (is.iod(val)) {
        return 0 != val % 1;
      }
      return false;
    };
    is.integer = function(val) {
      if (is.iod(val)) {
        return 0 == val % 1;
      }
      return false;
    };
    is.oof = function(val) {
      if (val) {
        var tp = _type(val);
        return "object" == tp || "function" == tp;
      }
      return false;
    };
    is.object = function(obj2) {
      return is.oof(obj2) && "function" != _class(obj2);
    };
    is.hash = is.plainObject = function(hash) {
      if (hash) {
        if ("object" == _class(hash)) {
          if (hash.nodeType || hash.setInterval) {
            return false;
          }
          return true;
        }
      }
      return false;
    };
    is.undef = function(val) {
      return "undefined" == _type(val);
    };
    is.fn = function(fn) {
      return "function" == _class(fn);
    };
    is.string = function(str) {
      return "string" == _class(str);
    };
    is.nos = function(val) {
      return is.iod(val) || is.string(val);
    };
    is.array = function(arr) {
      return "array" == _class(arr);
    };
    is.arraylike = function(arr) {
      if (!is.window(arr) && is.object(arr)) {
        var len = arr.length;
        if (is.integer(len) && len >= 0) {
          return true;
        }
      }
      return false;
    };
    is.window = function(val) {
      if (val && val.window == val) {
        return true;
      }
      return false;
    };
    is.empty = function(val) {
      if (is.string(val) || is.arraylike(val)) {
        return 0 === val.length;
      }
      if (is.hash(val)) {
        for (var key in val) {
          if (owns(val, key)) {
            return false;
          }
        }
      }
      return true;
    };
    is.element = function(elem) {
      if (elem && 1 === elem.nodeType) {
        return true;
      }
      return false;
    };
    is.regexp = function(val) {
      return "regexp" == _class(val);
    };
  }
});

// node_modules/cou/index.js
var require_cou = __commonJS({
  "node_modules/cou/index.js"(exports) {
    var is = require_min_is();
    var slice = [].slice;
    var _ = exports;
    _.is = is;
    _.extend = _.assign = extend;
    _.each = each;
    _.map = function(arr, fn) {
      var ret = [];
      each(arr, function(item, i, arr2) {
        ret[i] = fn(item, i, arr2);
      });
      return ret;
    };
    _.filter = function(arr, fn) {
      var ret = [];
      each(arr, function(item, i, arr2) {
        var val = fn(item, i, arr2);
        if (val)
          ret.push(item);
      });
      return ret;
    };
    _.some = function(arr, fn) {
      return -1 != findIndex(arr, fn);
    };
    _.every = function(arr, fn) {
      return -1 == findIndex(arr, negate(fn));
    };
    _.reduce = reduce;
    _.findIndex = findIndex;
    _.find = function(arr, fn) {
      var index = _.findIndex(arr, fn);
      if (-1 != index) {
        return arr[index];
      }
    };
    _.indexOf = indexOf;
    _.includes = function(val, sub) {
      return -1 != indexOf(val, sub);
    };
    _.toArray = toArray;
    _.slice = function(arr, start, end) {
      var ret = [];
      var len = getLength(arr);
      if (len >= 0) {
        start = start || 0;
        if (0 !== end) {
          end = end || len;
        }
        if (!is.fn(arr.slice)) {
          arr = toArray(arr);
        }
        ret = arr.slice(start, end);
      }
      return ret;
    };
    _.negate = negate;
    _.forIn = forIn;
    _.keys = keys;
    var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    _.trim = function(str) {
      if (null == str)
        return "";
      return ("" + str).replace(rtrim, "");
    };
    _.noop = function() {
    };
    _.len = getLength;
    function getLength(arr) {
      if (null != arr)
        return arr.length;
    }
    function each(arr, fn) {
      var len = getLength(arr);
      if (len && is.fn(fn)) {
        for (var i = 0; i < len; i++) {
          if (false === fn(arr[i], i, arr))
            break;
        }
      }
      return arr;
    }
    function findIndex(arr, fn) {
      var ret = -1;
      each(arr, function(item, i, arr2) {
        if (fn(item, i, arr2)) {
          ret = i;
          return false;
        }
      });
      return ret;
    }
    function toArray(arr) {
      var ret = [];
      each(arr, function(item) {
        ret.push(item);
      });
      return ret;
    }
    function extend(target) {
      if (target) {
        var sources = slice.call(arguments, 1);
        each(sources, function(src) {
          forIn(src, function(val, key) {
            if (!is.undef(val)) {
              target[key] = val;
            }
          });
        });
      }
      return target;
    }
    function negate(fn) {
      return function() {
        return !fn.apply(this, arguments);
      };
    }
    function indexOf(val, sub) {
      if (is.string(val))
        return val.indexOf(sub);
      return findIndex(val, function(item) {
        return sub === item;
      });
    }
    function reduce(arr, fn, prev) {
      each(arr, function(item, i) {
        prev = fn(prev, item, i, arr);
      });
      return prev;
    }
    function forIn(hash, fn) {
      if (hash) {
        for (var key in hash) {
          if (is.owns(hash, key)) {
            if (false === fn(hash[key], key, hash))
              break;
          }
        }
      }
      return hash;
    }
    function keys(hash) {
      var ret = [];
      forIn(hash, function(val, key) {
        ret.push(key);
      });
      return ret;
    }
  }
});

// node_modules/min-util/src/lang.js
var require_lang = __commonJS({
  "node_modules/min-util/src/lang.js"(exports, module) {
    module.exports = function(_) {
      var is = _.is;
      _.isString = is.string;
      _.isArray = is.array;
      _.isArrayLike = is.arraylike;
      _.isBoolean = is.bool;
      _.isElement = is.element;
      _.isEmpty = is.empty;
      _.isFunction = is.fn;
      _.isInteger = is.integer;
      _.isNaN = is.nan;
      _.isNumber = is.number;
      _.isObject = is.object;
      _.isPlainObject = is.plainObject;
      _.isRegExp = is.regexp;
      _.isString = is.string;
      _.isUndefined = is.undef;
    };
  }
});

// node_modules/min-util/src/util.js
var require_util = __commonJS({
  "node_modules/min-util/src/util.js"(exports, module) {
    module.exports = function(_) {
      var is = _.is;
      _.now = function() {
        return +/* @__PURE__ */ new Date();
      };
      _.constant = function(val) {
        return function() {
          return val;
        };
      };
      _.identity = function(val) {
        return val;
      };
      _.random = function(min, max) {
        return min + Math.floor(Math.random() * (max - min + 1));
      };
      _.mixin = function(dst, src, opt) {
        var keys = _.functions(src);
        if (dst) {
          if (is.fn(dst)) {
            opt = opt || {};
            var proto = dst.prototype;
            _.each(keys, function(key) {
              var fn = src[key];
              proto[key] = function() {
                var me = this;
                var args = [me.__value];
                args.push.apply(args, arguments);
                var ret = fn.apply(me, args);
                if (me.__chain) {
                  me.__value = ret;
                  return me;
                }
                return ret;
              };
            });
          } else {
            _.each(keys, function(key) {
              dst[key] = src[key];
            });
          }
        }
        return dst;
      };
      _.chain = function(val) {
        var ret = _(val);
        ret.__chain = true;
        return ret;
      };
      _.value = function() {
        this.__chain = false;
        return this.__value;
      };
      var uniqueId = 0;
      _.uniqueId = function(prefix) {
        uniqueId++;
        return _.toString(prefix) + uniqueId;
      };
    };
  }
});

// node_modules/min-util/src/array.js
var require_array = __commonJS({
  "node_modules/min-util/src/array.js"(exports, module) {
    module.exports = function(_) {
      var each = _.forEach = _.each;
      var includes = _.includes;
      var is = _.is;
      var proto = Array.prototype;
      _.reject = function(arr, fn) {
        return _.filter(arr, function(val, i, arr2) {
          return !fn(val, i, arr2);
        });
      };
      _.without = function(arr) {
        var other = _.slice(arguments, 1);
        return _.difference(arr, other);
      };
      _.difference = function(arr, other) {
        var ret = [];
        _.each(arr, function(val) {
          if (!includes(other, val)) {
            ret.push(val);
          }
        });
        return ret;
      };
      _.pluck = function(arr, key) {
        return _.map(arr, function(item) {
          if (item)
            return item[key];
        });
      };
      _.nth = function(arr, n) {
        n = getRealIndex(n, arr);
        n = n || 0;
        var ret;
        if (_.isString(arr)) {
          ret = arr.charAt(n);
        } else {
          ret = arr[n];
        }
        return ret;
      };
      _.first = function(arr) {
        if (arr)
          return _.nth(arr, 0);
      };
      _.last = function(arr) {
        var len = _.len(arr);
        if (len) {
          return _.nth(arr, len - 1);
        }
      };
      _.asyncMap = function(arr, fn, cb) {
        var ret = [];
        var count = 0;
        var hasDone, hasStart;
        each(arr, function(arg, i) {
          hasStart = true;
          fn(arg, function(err, val) {
            if (hasDone)
              return;
            count++;
            if (err) {
              hasDone = true;
              return cb(err);
            }
            ret[i] = val;
            if (count == arr.length) {
              hasDone = true;
              cb(null, ret);
            }
          });
        });
        if (!hasStart)
          cb(null);
      };
      _.uniq = function(arr) {
        return _.uniqBy(arr);
      };
      _.uniqBy = function(arr, fn) {
        var ret = [];
        var pool = [];
        if (!is.fn(fn)) {
          fn = null;
        }
        each(arr, function(item) {
          var val = item;
          if (fn) {
            val = fn(item);
          }
          if (!includes(pool, val)) {
            pool.push(val);
            ret.push(item);
          }
        });
        return ret;
      };
      _.flatten = function(arrs) {
        var ret = [];
        each(arrs, function(arr) {
          if (is.arraylike(arr)) {
            each(arr, function(item) {
              ret.push(item);
            });
          } else
            ret.push(arr);
        });
        return ret;
      };
      _.union = function() {
        return _.uniq(_.flatten(arguments));
      };
      _.sampleSize = function(arr, n) {
        var ret = _.toArray(arr);
        var len = ret.length;
        var need = Math.min(n || 1, len);
        for (var i = 0; i < len; i++) {
          var rand = _.random(i, len - 1);
          var tmp = ret[rand];
          ret[rand] = ret[i];
          ret[i] = tmp;
        }
        ret.length = need;
        return ret;
      };
      _.sample = function(arr) {
        return _.first(_.sampleSize(arr, 1));
      };
      _.shuffle = function(arr) {
        return _.sampleSize(arr, Infinity);
      };
      _.compact = function(arr) {
        return _.filter(arr, _.identity);
      };
      _.rest = function(arr) {
        return _.slice(arr, 1);
      };
      _.invoke = function() {
        var args = arguments;
        var arr = args[0];
        var fn = args[1];
        var isFunc = is.fn(fn);
        args = _.slice(args, 2);
        return _.map(arr, function(item) {
          if (isFunc) {
            return fn.apply(item, args);
          }
          if (null != item) {
            var method = item[fn];
            if (is.fn(method)) {
              return method.apply(item, args);
            }
          }
        });
      };
      _.partition = function(arr, fn) {
        var hash = _.groupBy(arr, function(val, i, arr2) {
          var ret = fn(val, i, arr2);
          if (ret)
            return 1;
          return 2;
        });
        return [hash[1] || [], hash[2] || []];
      };
      _.groupBy = function(arr, fn) {
        var hash = {};
        _.each(arr, function(val, i, arr2) {
          var ret = fn(val, i, arr2);
          hash[ret] = hash[ret] || [];
          hash[ret].push(val);
        });
        return hash;
      };
      _.range = function() {
        var args = arguments;
        if (args.length < 2) {
          return _.range(args[1], args[0]);
        }
        var start = args[0] || 0;
        var last = args[1] || 0;
        var step = args[2];
        if (!is.number(step)) {
          step = 1;
        }
        var count = last - start;
        if (0 != step) {
          count = count / step;
        }
        var ret = [];
        var val = start;
        for (var i = 0; i < count; i++) {
          ret.push(val);
          val += step;
        }
        return ret;
      };
      _.pullAt = function(arr) {
        var indexes = _.slice(arguments, 1);
        return mutateDifference(arr, indexes);
      };
      _.remove = function(arr, fn) {
        var len = _.len(arr) || 0;
        var indexes = [];
        while (len--) {
          if (fn(arr[len], len, arr)) {
            indexes.push(len);
          }
        }
        return mutateDifference(arr, indexes);
      };
      _.fill = function(arr, val, start, end) {
        var size = _.size(arr);
        start = getRealIndex(start, arr) || 0;
        end = getRealIndex(end, arr) || size;
        for (var i = start; i < end; i++) {
          arr[i] = val;
        }
        return arr;
      };
      _.size = function(val) {
        var size = 0;
        if (val) {
          var len = val.length;
          if (_.isInteger(len) && len >= 0) {
            size = len;
          } else if (_.isObject(val)) {
            size = _.keys(val).length;
          }
        }
        return size;
      };
      function getRealIndex(index, arr) {
        var size = _.size(arr);
        if (index < 0) {
          index += size;
        }
        if (index < 0) {
          index = 0;
        }
        if (index > size) {
          index = size;
        }
        return index || 0;
      }
      function mutateDifference(arr, indexes) {
        var ret = [];
        var len = _.len(indexes);
        if (len) {
          indexes = indexes.sort(function(a, b) {
            return a - b;
          });
          while (len--) {
            var index = indexes[len];
            ret.push(proto.splice.call(arr, index, 1)[0]);
          }
        }
        ret.reverse();
        return ret;
      }
    };
  }
});

// node_modules/min-util/src/object.js
var require_object = __commonJS({
  "node_modules/min-util/src/object.js"(exports, module) {
    module.exports = function(_) {
      var is = _.is;
      var forIn = _.forIn;
      _.only = function(obj, keys) {
        obj = obj || {};
        if (is.string(keys))
          keys = keys.split(/ +/);
        return _.reduce(keys, function(ret, key) {
          if (null != obj[key])
            ret[key] = obj[key];
          return ret;
        }, {});
      };
      _.values = function(obj) {
        return _.map(_.keys(obj), function(key) {
          return obj[key];
        });
      };
      _.pick = function(obj, fn) {
        if (!is.fn(fn)) {
          return _.pick(obj, function(val, key) {
            return key == fn;
          });
        }
        var ret = {};
        forIn(obj, function(val, key, obj2) {
          if (fn(val, key, obj2)) {
            ret[key] = val;
          }
        });
        return ret;
      };
      _.functions = function(obj) {
        return _.keys(_.pick(obj, function(val) {
          return is.fn(val);
        }));
      };
      _.mapKeys = function(obj, fn) {
        var ret = {};
        forIn(obj, function(val, key, obj2) {
          var newKey = fn(val, key, obj2);
          ret[newKey] = val;
        });
        return ret;
      };
      _.mapObject = _.mapValues = function(obj, fn) {
        var ret = {};
        forIn(obj, function(val, key, obj2) {
          ret[key] = fn(val, key, obj2);
        });
        return ret;
      };
      _.get = function(obj, path) {
        path = toPath(path);
        if (path.length) {
          var flag = _.every(path, function(key) {
            if (null != obj) {
              obj = obj[key];
              return true;
            }
          });
          if (flag)
            return obj;
        }
      };
      _.has = function(obj, path) {
        path = toPath(path);
        if (path.length) {
          var flag = _.every(path, function(key) {
            if (null != obj && is.owns(obj, key)) {
              obj = obj[key];
              return true;
            }
          });
          if (flag)
            return true;
        }
        return false;
      };
      _.set = function(obj, path, val) {
        path = toPath(path);
        var cur = obj;
        _.every(path, function(key, i) {
          if (is.oof(cur)) {
            if (i + 1 == path.length) {
              cur[key] = val;
            } else {
              var item = cur[key];
              if (null == item) {
                var item = {};
                if (~~key == key) {
                  item = [];
                }
              }
              cur = cur[key] = item;
              return true;
            }
          }
        });
        return obj;
      };
      _.create = function() {
        function Object2() {
        }
        return function(proto, property) {
          if ("object" != typeof proto) {
            proto = null;
          }
          Object2.prototype = proto;
          return _.extend(new Object2(), property);
        };
      }();
      _.defaults = function() {
        var args = arguments;
        var target = args[0];
        var sources = _.slice(args, 1);
        if (target) {
          _.each(sources, function(src) {
            _.mapObject(src, function(val, key) {
              if (is.undef(target[key])) {
                target[key] = val;
              }
            });
          });
        }
        return target;
      };
      _.isMatch = function(obj, src) {
        var ret = true;
        obj = obj || {};
        forIn(src, function(val, key) {
          if (val !== obj[key]) {
            ret = false;
            return false;
          }
        });
        return ret;
      };
      _.toPlainObject = function(val) {
        var ret = {};
        forIn(val, function(val2, key) {
          ret[key] = val2;
        });
        return ret;
      };
      _.invert = function(obj) {
        var ret = {};
        forIn(obj, function(val, key) {
          ret[val] = key;
        });
        return ret;
      };
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
      var reEscapeChar = /\\(\\)?/g;
      function toPath(val) {
        if (is.array(val))
          return val;
        var ret = [];
        _.toString(val).replace(rePropName, function(match, number, quote, string) {
          var item = number || match;
          if (quote) {
            item = string.replace(reEscapeChar, "$1");
          }
          ret.push(item);
        });
        return ret;
      }
    };
  }
});

// node_modules/min-util/src/cache.js
var require_cache = __commonJS({
  "node_modules/min-util/src/cache.js"(exports, module) {
    var cou = require_cou();
    var is = cou.is;
    module.exports = Cache;
    function Cache() {
      this.data = {};
    }
    var proto = Cache.prototype;
    proto.has = function(key) {
      return is.owns(this.data, key);
    };
    proto.get = function(key) {
      return this.data[key];
    };
    proto.set = function(key, val) {
      this.data[key] = val;
    };
    proto["delete"] = function(key) {
      delete this.data[key];
    };
  }
});

// node_modules/min-util/src/function.js
var require_function = __commonJS({
  "node_modules/min-util/src/function.js"(exports, module) {
    module.exports = function(_) {
      var is = _.is;
      var slice = _.slice;
      _.bind = function(fn, ctx) {
        if (is.string(ctx)) {
          var obj = fn;
          fn = obj[ctx];
          ctx = obj;
        }
        if (!is.fn(fn))
          return fn;
        var args = slice(arguments, 2);
        ctx = ctx || this;
        return function() {
          return fn.apply(ctx, _.flatten([args, arguments]));
        };
      };
      _.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = _.create(superCtor.prototype, {
          constructor: ctor
        });
      };
      _.delay = function(fn, wait) {
        var args = _.slice(arguments, 2);
        return setTimeout(function() {
          fn.apply(this, args);
        }, wait);
      };
      _.before = function(n, fn) {
        return function() {
          if (n > 1) {
            n--;
            return fn.apply(this, arguments);
          }
        };
      };
      _.once = function(fn) {
        return _.before(2, fn);
      };
      _.after = function(n, fn) {
        return function() {
          if (n > 1) {
            n--;
          } else {
            return fn.apply(this, arguments);
          }
        };
      };
      _.throttle = function(fn, wait, opt) {
        wait = wait || 0;
        opt = _.extend({
          leading: true,
          trailing: true,
          maxWait: wait
        }, opt);
        return _.debounce(fn, wait, opt);
      };
      _.debounce = function(fn, wait, opt) {
        wait = wait || 0;
        opt = _.extend({
          leading: false,
          trailing: true
        }, opt);
        var maxWait = opt.maxWait;
        var lastExec = 0;
        var lastCall = 0;
        var now = _.now();
        var timer;
        if (!opt.leading) {
          lastExec = now;
        }
        function ifIsCD() {
          if (now - lastExec > wait)
            return false;
          if (maxWait && now - lastCall > maxWait)
            return false;
          return true;
        }
        function exec(fn2, ctx, args) {
          lastExec = _.now();
          return fn2.apply(ctx, args);
        }
        function cancel() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function debounced() {
          now = _.now();
          var isCD = ifIsCD();
          lastCall = now;
          var me = this;
          var args = arguments;
          cancel();
          if (!isCD) {
            exec(fn, me, args);
          } else {
            if (opt.trailing) {
              timer = _.delay(function() {
                exec(fn, me, args);
              }, wait);
            }
          }
        }
        debounced.cancel = cancel;
        return debounced;
      };
      function memoize(fn) {
        var cache = new memoize.Cache();
        function memoized() {
          var args = arguments;
          var key = args[0];
          if (!cache.has(key)) {
            var ret = fn.apply(this, args);
            cache.set(key, ret);
          }
          return cache.get(key);
        }
        memoized.cache = cache;
        return memoized;
      }
      memoize.Cache = require_cache();
      _.memoize = memoize;
      _.wrap = function(val, fn) {
        return function() {
          var args = [val];
          args.push.apply(args, arguments);
          return fn.apply(this, args);
        };
      };
      _.curry = function(fn) {
        var len = fn.length;
        return setter([]);
        function setter(args) {
          return function() {
            var arr = args.concat(_.slice(arguments));
            if (arr.length >= len) {
              arr.length = len;
              return fn.apply(this, arr);
            }
            return setter(arr);
          };
        }
      };
    };
  }
});

// node_modules/min-util/src/string.js
var require_string = __commonJS({
  "node_modules/min-util/src/string.js"(exports, module) {
    module.exports = function(_) {
      _.tostr = _.toString = tostr;
      var indexOf = _.indexOf;
      _.split = function(str, separator, limit) {
        str = tostr(str);
        return str.split(separator, limit);
      };
      _.capitalize = function(str) {
        str = tostr(str);
        return str.charAt(0).toUpperCase() + str.substr(1).toLowerCase();
      };
      _.upperFirst = function(str) {
        str = tostr(str);
        return str.charAt(0).toUpperCase() + str.substr(1);
      };
      _.lowerFirst = function(str) {
        str = tostr(str);
        return str.charAt(0).toLowerCase() + str.substr(1);
      };
      _.camelCase = function(str) {
        str = tostr(str);
        var arr = str.split(/[^\w]|_+/);
        arr = _.map(arr, function(val) {
          return _.capitalize(val);
        });
        return _.lowerFirst(arr.join(""));
      };
      _.startsWith = function(str, val) {
        return 0 == indexOf(str, val);
      };
      _.endsWith = function(str, val) {
        val += "";
        return val == _.slice(str, _.len(str) - _.len(val));
      };
      _.toLower = _.lower = function(str) {
        return tostr(str).toLowerCase();
      };
      _.toUpper = _.upper = function(str) {
        return tostr(str).toUpperCase();
      };
      _.repeat = function(str, count) {
        return _.map(_.range(count), function() {
          return str;
        }).join("");
      };
      _.padStart = function(str, len, chars) {
        str = tostr(str);
        len = len || 0;
        var delta = len - str.length;
        return getPadStr(chars, delta) + str;
      };
      _.padEnd = function(str, len, chars) {
        str = tostr(str);
        len = len || 0;
        var delta = len - str.length;
        return str + getPadStr(chars, delta);
      };
      var htmlEscapes = {
        "&": "&amp",
        "<": "&lt",
        ">": "&gt",
        '"': "&quot",
        "'": "&#39"
      };
      _.escape = function(str) {
        return tostr(str).replace(/[&<>"']/g, function(item) {
          return htmlEscapes[item] || item;
        });
      };
      _.template = function(str) {
        var arr = ['with(data) {var ret = ""'];
        _.each(_.split(str, "<%"), function(x, i) {
          var two = x.split("%>");
          if (two[1]) {
            genJS(_.trim(two[0]));
            return filter(two[1]);
          }
          filter(two[0]);
        });
        arr.push("return ret}");
        var func = new Function("data", arr.join("\n"));
        var internalData = {
          _
        };
        var ret = function(data) {
          return func(_.extend({}, internalData, data));
        };
        return ret;
        function genJS(jsstr) {
          var first = _.first(jsstr);
          if (first === "=" || first === "-") {
            var text = _.slice(jsstr, 1);
            if (first === "-") {
              text = "_.escape(" + text + ")";
            }
            arr.push("ret += " + text);
          } else {
            arr.push(jsstr);
          }
        }
        function filter(html) {
          arr.push('ret += "' + html.replace(/('|"|\\)/g, "\\$1").replace(/\r/g, "\\r").replace(/\n/g, "\\n") + '"');
        }
      };
      function getPadStr(chars, len) {
        chars = tostr(chars) || " ";
        var count = Math.floor(len / chars.length) + 1;
        return _.repeat(chars, count).slice(0, len);
      }
      function tostr(str) {
        if (str || 0 == str)
          return str + "";
        return "";
      }
    };
  }
});

// node_modules/min-util/src/math.js
var require_math = __commonJS({
  "node_modules/min-util/src/math.js"(exports, module) {
    module.exports = function(_) {
      _.sum = function(arr) {
        return _.reduce(arr, function(sum, val) {
          return sum + val;
        }, 0);
      };
      _.max = function(arr, fn) {
        var index = -1;
        var data = -Infinity;
        fn = fn || _.identity;
        _.each(arr, function(val, i) {
          val = fn(val);
          if (val > data) {
            data = val;
            index = i;
          }
        });
        if (index > -1) {
          return arr[index];
        }
        return data;
      };
      _.min = function(arr, fn) {
        var index = -1;
        var data = Infinity;
        fn = fn || _.identity;
        _.each(arr, function(val, i) {
          val = fn(val);
          if (val < data) {
            data = val;
            index = i;
          }
        });
        if (index > -1) {
          return arr[index];
        }
        return data;
      };
    };
  }
});

// node_modules/min-util/src/index.js
var require_src = __commonJS({
  "node_modules/min-util/src/index.js"(exports, module) {
    var cou = require_cou();
    module.exports = cou.extend(_, cou);
    require_lang()(_);
    require_util()(_);
    require_array()(_);
    require_object()(_);
    require_function()(_);
    require_string()(_);
    require_math()(_);
    _.mixin(_, _);
    function _(val) {
      if (!(this instanceof _))
        return new _(val);
      this.__value = val;
      this.__chain = false;
    }
  }
});

// node_modules/min-util/index.js
var require_min_util = __commonJS({
  "node_modules/min-util/index.js"(exports, module) {
    module.exports = require_src();
  }
});

// node_modules/min-qs/index.js
var require_min_qs = __commonJS({
  "node_modules/min-qs/index.js"(exports) {
    var _ = require_min_util();
    var is = _.is;
    var defaultOption = {
      sep: "&",
      eq: "=",
      encode: encodeURIComponent,
      decode: decodeURIComponent,
      keepRaw: false,
      sort: null,
      ignoreValues: [void 0]
    };
    exports.parse = function(qs, sep, eq, opt) {
      qs += "";
      opt = getOpt(sep, eq, opt);
      var decode = opt.decode;
      qs = qs.split(opt.sep);
      return _.reduce(qs, function(ret, arr) {
        arr = arr.split(opt.eq);
        if (2 == arr.length) {
          var k = arr[0];
          var v = arr[1];
          if (!opt.keepRaw) {
            try {
              k = decode(k);
              v = decode(v);
            } catch (ignore) {
            }
          }
          ret[k] = v;
        }
        return ret;
      }, {});
    };
    exports.stringify = function(obj, sep, eq, opt) {
      opt = getOpt(sep, eq, opt);
      var keys = _.keys(obj);
      var sort = opt.sort;
      if (sort) {
        if (is.fn(sort)) {
          keys.sort(sort);
        } else {
          keys.sort();
        }
      }
      var encode = opt.encode;
      var arr = [];
      _.each(keys, function(key) {
        var val = obj[key];
        if (!_.includes(opt.ignoreValues, val)) {
          if (is.nan(val) || null == val) {
            val = "";
          }
          if (!opt.keepRaw) {
            key = encode(key);
            val = encode(val);
          }
          arr.push(key + opt.eq + val);
        }
      });
      return arr.join(opt.sep);
    };
    function getOpt(sep, eq, opt) {
      opt = _.find(arguments, function(val) {
        return is.object(val);
      });
      sep = is.nos(sep) ? sep : void 0;
      eq = is.nos(eq) ? eq : void 0;
      opt = _.extend({}, defaultOption, opt, { sep, eq });
      return opt;
    }
  }
});

// node_modules/@rgrove/parse-xml/dist/browser.js
var require_browser = __commonJS({
  "node_modules/@rgrove/parse-xml/dist/browser.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      XmlCdata: () => XmlCdata,
      XmlComment: () => XmlComment,
      XmlDeclaration: () => XmlDeclaration,
      XmlDocument: () => XmlDocument,
      XmlDocumentType: () => XmlDocumentType,
      XmlElement: () => XmlElement2,
      XmlError: () => XmlError,
      XmlNode: () => XmlNode2,
      XmlProcessingInstruction: () => XmlProcessingInstruction,
      XmlText: () => XmlText2,
      parseXml: () => parseXml2
    });
    module.exports = __toCommonJS(src_exports);
    var emptyString = "";
    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var StringScanner = class {
      constructor(string) {
        this.k = this.q(string, true);
        this.d = 0;
        this.length = string.length;
        this.n = this.k !== this.length;
        this.m = string;
        if (this.n) {
          let charsToBytes = [];
          for (let byteIndex = 0, charIndex = 0; charIndex < this.k; ++charIndex) {
            charsToBytes[charIndex] = byteIndex;
            byteIndex += string.codePointAt(byteIndex) > 65535 ? 2 : 1;
          }
          this.y = charsToBytes;
        }
      }
      /**
       * Whether the current character index is at the end of the input string.
       */
      get z() {
        return this.d >= this.k;
      }
      // -- Protected Methods ------------------------------------------------------
      /**
       * Returns the number of characters in the given string, which may differ from
       * the byte length if the string contains multibyte characters.
       */
      q(string, multiByteSafe = this.n) {
        return multiByteSafe ? string.replace(surrogatePair, "_").length : string.length;
      }
      // -- Public Methods ---------------------------------------------------------
      /**
       * Advances the scanner by the given number of characters, stopping if the end
       * of the string is reached.
       */
      g(count = 1) {
        this.d = Math.min(this.k, this.d + count);
      }
      /**
       * Returns the byte index of the given character index in the string. The two
       * may differ in strings that contain multibyte characters.
       */
      i(charIndex = this.d) {
        var _a;
        return this.n ? (_a = this.y[charIndex]) != null ? _a : Infinity : charIndex;
      }
      /**
       * Consumes and returns the given number of characters if possible, advancing
       * the scanner and stopping if the end of the string is reached.
       *
       * If no characters could be consumed, an empty string will be returned.
       */
      F(count = 1) {
        let chars = this.h(count);
        this.g(count);
        return chars;
      }
      /**
       * Consumes a match for the given sticky regex, advances the scanner, updates
       * the `lastIndex` property of the regex, and returns the matching string.
       *
       * The regex must have a sticky flag ("y") so that its `lastIndex` prop can be
       * used to anchor the match at the current scanner position.
       *
       * Returns the consumed string, or an empty string if nothing was consumed.
       */
      G(regex) {
        if (!regex.sticky) {
          throw new Error('`regex` must have a sticky flag ("y")');
        }
        regex.lastIndex = this.i();
        let result = regex.exec(this.m);
        if (result === null || result.length === 0) {
          return emptyString;
        }
        let match = result[0];
        this.g(this.q(match));
        return match;
      }
      /**
       * Consumes and returns all characters for which the given function returns a
       * truthy value, stopping on the first falsy return value or if the end of the
       * input is reached.
       */
      v(fn) {
        let char;
        let match = emptyString;
        while ((char = this.h()) && fn(char)) {
          match += char;
          this.g();
        }
        return match;
      }
      /**
       * Consumes the given string if it exists at the current character index, and
       * advances the scanner.
       *
       * If the given string doesn't exist at the current character index, an empty
       * string will be returned and the scanner will not be advanced.
       */
      Q(stringToConsume) {
        if (this.b(stringToConsume)) {
          return stringToConsume;
        }
        if (this.n) {
          let { length } = stringToConsume;
          let charLengthToMatch = this.q(stringToConsume);
          if (charLengthToMatch !== length && stringToConsume === this.h(charLengthToMatch)) {
            this.g(charLengthToMatch);
            return stringToConsume;
          }
        }
        return emptyString;
      }
      /**
       * Does the same thing as `consumeString()`, but doesn't support consuming
       * multibyte characters. This can be faster if you only need to match single
       * byte characters.
       */
      b(stringToConsume) {
        let { length } = stringToConsume;
        if (this.h(length) === stringToConsume) {
          this.g(length);
          return stringToConsume;
        }
        return emptyString;
      }
      /**
       * Consumes characters until the given global regex is matched, advancing the
       * scanner up to (but not beyond) the beginning of the match. If the regex
       * doesn't match, nothing will be consumed.
       *
       * Returns the consumed string, or an empty string if nothing was consumed.
       */
      A(regex) {
        let restOfString = this.m.slice(this.i());
        let matchByteIndex = restOfString.search(regex);
        if (matchByteIndex <= 0) {
          return emptyString;
        }
        let result = restOfString.slice(0, matchByteIndex);
        this.g(this.q(result));
        return result;
      }
      /**
       * Consumes characters until the given string is found, advancing the scanner
       * up to (but not beyond) that point. If the string is never found, nothing
       * will be consumed.
       *
       * Returns the consumed string, or an empty string if nothing was consumed.
       */
      t(searchString) {
        let { m: string } = this;
        let byteIndex = this.i();
        let matchByteIndex = string.indexOf(searchString, byteIndex);
        if (matchByteIndex <= 0) {
          return emptyString;
        }
        let result = string.slice(byteIndex, matchByteIndex);
        this.g(this.q(result));
        return result;
      }
      /**
       * Returns the given number of characters starting at the current character
       * index, without advancing the scanner and without exceeding the end of the
       * input string.
       */
      h(count = 1) {
        let { d: charIndex, n: multiByteMode, m: string } = this;
        if (multiByteMode) {
          if (charIndex >= this.k) {
            return emptyString;
          }
          return string.slice(
            this.i(charIndex),
            this.i(charIndex + count)
          );
        }
        return string.slice(charIndex, charIndex + count);
      }
      /**
       * Resets the scanner position to the given character _index_, or to the start
       * of the input string if no index is given.
       *
       * If _index_ is negative, the scanner position will be moved backward by that
       * many characters, stopping if the beginning of the string is reached.
       */
      o(index = 0) {
        this.d = index >= 0 ? Math.min(this.k, index) : Math.max(0, this.d + index);
      }
    };
    var attValueCharDoubleQuote = /[^"&<]+/y;
    var attValueCharSingleQuote = /[^'&<]+/y;
    var attValueNormalizedWhitespace = /\r\n|[\n\r\t]/g;
    var endCharData = /<|&|]]>/;
    var predefinedEntities = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }));
    function isNameChar(char) {
      let cp = getCodePoint(char);
      return cp >= 97 && cp <= 122 || cp >= 65 && cp <= 90 || cp >= 48 && cp <= 57 || cp === 45 || cp === 46 || cp === 183 || cp >= 768 && cp <= 879 || cp >= 8255 && cp <= 8256 || isNameStartChar(char, cp);
    }
    function isNameStartChar(char, cp = getCodePoint(char)) {
      return cp >= 97 && cp <= 122 || cp >= 65 && cp <= 90 || cp === 58 || cp === 95 || cp >= 192 && cp <= 214 || cp >= 216 && cp <= 246 || cp >= 248 && cp <= 767 || cp >= 880 && cp <= 893 || cp >= 895 && cp <= 8191 || cp >= 8204 && cp <= 8205 || cp >= 8304 && cp <= 8591 || cp >= 11264 && cp <= 12271 || cp >= 12289 && cp <= 55295 || cp >= 63744 && cp <= 64975 || cp >= 65008 && cp <= 65533 || cp >= 65536 && cp <= 983039;
    }
    function isReferenceChar(char) {
      return char === "#" || isNameChar(char);
    }
    function isWhitespace(char) {
      let cp = getCodePoint(char);
      return cp === 32 || cp === 9 || cp === 10 || cp === 13;
    }
    function isXmlCodePoint(cp) {
      return cp === 9 || cp === 10 || cp === 13 || cp >= 32 && cp <= 55295 || cp >= 57344 && cp <= 65533 || cp >= 65536 && cp <= 1114111;
    }
    function getCodePoint(char) {
      return char.codePointAt(0) || -1;
    }
    var _XmlNode = class {
      constructor() {
        this.parent = null;
        this.start = -1;
        this.end = -1;
      }
      /**
       * Document that contains this node, or `null` if this node is not associated
       * with a document.
       */
      get document() {
        var _a, _b;
        return (_b = (_a = this.parent) == null ? void 0 : _a.document) != null ? _b : null;
      }
      /**
       * Whether this node is the root node of the document (also known as the
       * document element).
       */
      get isRootNode() {
        return this.parent !== null && this.parent === this.document && this.type === _XmlNode.TYPE_ELEMENT;
      }
      /**
       * Whether whitespace should be preserved in the content of this element and
       * its children.
       *
       * This is influenced by the value of the special `xml:space` attribute, and
       * will be `true` for any node whose `xml:space` attribute is set to
       * "preserve". If a node has no such attribute, it will inherit the value of
       * the nearest ancestor that does (if any).
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space
       */
      get preserveWhitespace() {
        var _a;
        return !!((_a = this.parent) == null ? void 0 : _a.preserveWhitespace);
      }
      /**
       * Type of this node.
       *
       * The value of this property is a string that matches one of the static
       * `TYPE_*` properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`,
       * `TYPE_TEXT`, etc.).
       *
       * The `XmlNode` class itself is a base class and doesn't have its own type
       * name.
       */
      get type() {
        return "";
      }
      /**
       * Returns a JSON-serializable object representing this node, minus properties
       * that could result in circular references.
       */
      toJSON() {
        let json = {
          type: this.type
        };
        if (this.isRootNode) {
          json.isRootNode = true;
        }
        if (this.preserveWhitespace) {
          json.preserveWhitespace = true;
        }
        if (this.start !== -1) {
          json.start = this.start;
          json.end = this.end;
        }
        return json;
      }
    };
    var XmlNode2 = _XmlNode;
    XmlNode2.TYPE_CDATA = "cdata";
    XmlNode2.TYPE_COMMENT = "comment";
    XmlNode2.TYPE_DOCUMENT = "document";
    XmlNode2.TYPE_DOCUMENT_TYPE = "doctype";
    XmlNode2.TYPE_ELEMENT = "element";
    XmlNode2.TYPE_PROCESSING_INSTRUCTION = "pi";
    XmlNode2.TYPE_TEXT = "text";
    XmlNode2.TYPE_XML_DECLARATION = "xmldecl";
    var XmlText2 = class extends XmlNode2 {
      constructor(text = "") {
        super();
        this.text = text;
      }
      get type() {
        return XmlNode2.TYPE_TEXT;
      }
      toJSON() {
        return Object.assign(XmlNode2.prototype.toJSON.call(this), {
          text: this.text
        });
      }
    };
    var XmlCdata = class extends XmlText2 {
      get type() {
        return XmlNode2.TYPE_CDATA;
      }
    };
    var XmlComment = class extends XmlNode2 {
      constructor(content = "") {
        super();
        this.content = content;
      }
      get type() {
        return XmlNode2.TYPE_COMMENT;
      }
      toJSON() {
        return Object.assign(XmlNode2.prototype.toJSON.call(this), {
          content: this.content
        });
      }
    };
    var XmlDeclaration = class extends XmlNode2 {
      constructor(version, encoding, standalone) {
        super();
        this.version = version;
        this.encoding = encoding != null ? encoding : null;
        this.standalone = standalone != null ? standalone : null;
      }
      get type() {
        return XmlNode2.TYPE_XML_DECLARATION;
      }
      toJSON() {
        let json = XmlNode2.prototype.toJSON.call(this);
        json.version = this.version;
        for (let key of ["encoding", "standalone"]) {
          if (this[key] !== null) {
            json[key] = this[key];
          }
        }
        return json;
      }
    };
    var XmlElement2 = class extends XmlNode2 {
      constructor(name, attributes = /* @__PURE__ */ Object.create(null), children = []) {
        super();
        this.name = name;
        this.attributes = attributes;
        this.children = children;
      }
      /**
       * Whether this element is empty (meaning it has no children).
       */
      get isEmpty() {
        return this.children.length === 0;
      }
      get preserveWhitespace() {
        let node = this;
        while (node instanceof XmlElement2) {
          if ("xml:space" in node.attributes) {
            return node.attributes["xml:space"] === "preserve";
          }
          node = node.parent;
        }
        return false;
      }
      /**
       * Text content of this element and all its descendants.
       */
      get text() {
        return this.children.map((child) => "text" in child ? child.text : "").join("");
      }
      get type() {
        return XmlNode2.TYPE_ELEMENT;
      }
      toJSON() {
        return Object.assign(XmlNode2.prototype.toJSON.call(this), {
          name: this.name,
          attributes: this.attributes,
          children: this.children.map((child) => child.toJSON())
        });
      }
    };
    var XmlDocument = class extends XmlNode2 {
      constructor(children = []) {
        super();
        this.children = children;
      }
      get document() {
        return this;
      }
      /**
       * Root element of this document, or `null` if this document is empty.
       */
      get root() {
        for (let child of this.children) {
          if (child instanceof XmlElement2) {
            return child;
          }
        }
        return null;
      }
      /**
       * Text content of this document and all its descendants.
       */
      get text() {
        return this.children.map((child) => "text" in child ? child.text : "").join("");
      }
      get type() {
        return XmlNode2.TYPE_DOCUMENT;
      }
      toJSON() {
        return Object.assign(XmlNode2.prototype.toJSON.call(this), {
          children: this.children.map((child) => child.toJSON())
        });
      }
    };
    var XmlDocumentType = class extends XmlNode2 {
      constructor(name, publicId, systemId, internalSubset) {
        super();
        this.name = name;
        this.publicId = publicId != null ? publicId : null;
        this.systemId = systemId != null ? systemId : null;
        this.internalSubset = internalSubset != null ? internalSubset : null;
      }
      get type() {
        return XmlNode2.TYPE_DOCUMENT_TYPE;
      }
      toJSON() {
        let json = XmlNode2.prototype.toJSON.call(this);
        json.name = this.name;
        for (let key of ["publicId", "systemId", "internalSubset"]) {
          if (this[key] !== null) {
            json[key] = this[key];
          }
        }
        return json;
      }
    };
    var XmlError = class extends Error {
      constructor(message, charIndex, xml) {
        let column = 1;
        let excerpt = "";
        let line = 1;
        for (let i = 0; i < charIndex; ++i) {
          let char = xml[i];
          if (char === "\n") {
            column = 1;
            excerpt = "";
            line += 1;
          } else {
            column += 1;
            excerpt += char;
          }
        }
        let eol = xml.indexOf("\n", charIndex);
        excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);
        let excerptStart = 0;
        if (excerpt.length > 50) {
          if (column < 40) {
            excerpt = excerpt.slice(0, 50);
          } else {
            excerptStart = column - 20;
            excerpt = excerpt.slice(excerptStart, column + 30);
          }
        }
        super(
          `${message} (line ${line}, column ${column})
  ${excerpt}
` + " ".repeat(column - excerptStart + 1) + "^\n"
        );
        this.column = column;
        this.excerpt = excerpt;
        this.line = line;
        this.name = "XmlError";
        this.pos = charIndex;
      }
    };
    var XmlProcessingInstruction = class extends XmlNode2 {
      constructor(name, content = "") {
        super();
        this.name = name;
        this.content = content;
      }
      get type() {
        return XmlNode2.TYPE_PROCESSING_INSTRUCTION;
      }
      toJSON() {
        return Object.assign(XmlNode2.prototype.toJSON.call(this), {
          name: this.name,
          content: this.content
        });
      }
    };
    var emptyString2 = "";
    var Parser = class {
      /**
       * @param xml XML string to parse.
       * @param options Parser options.
       */
      constructor(xml, options = {}) {
        let doc = this.document = new XmlDocument();
        let scanner = this.c = new StringScanner(xml);
        this.l = doc;
        this.f = options;
        if (this.f.includeOffsets) {
          doc.start = 0;
          doc.end = xml.length;
        }
        scanner.b("\uFEFF");
        this.H();
        if (!this.B()) {
          throw this.a("Root element is missing or invalid");
        }
        while (this.w()) {
        }
        if (!scanner.z) {
          throw this.a("Extra content at the end of the document");
        }
      }
      /**
       * Adds the given `XmlNode` as a child of `this.currentNode`.
       */
      j(node, charIndex) {
        node.parent = this.l;
        if (this.f.includeOffsets) {
          node.start = this.c.i(charIndex);
          node.end = this.c.i();
        }
        this.l.children.push(node);
        return true;
      }
      /**
       * Adds the given _text_ to the document, either by appending it to a
       * preceding `XmlText` node (if possible) or by creating a new `XmlText` node.
       */
      x(text, charIndex) {
        let { children } = this.l;
        let { length } = children;
        text = normalizeLineBreaks(text);
        if (length > 0) {
          let prevNode = children[length - 1];
          if ((prevNode == null ? void 0 : prevNode.type) === XmlNode2.TYPE_TEXT) {
            let textNode = prevNode;
            textNode.text += text;
            if (this.f.includeOffsets) {
              textNode.end = this.c.i();
            }
            return true;
          }
        }
        return this.j(new XmlText2(text), charIndex);
      }
      /**
       * Consumes element attributes.
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-starttags
       */
      I() {
        let attributes = /* @__PURE__ */ Object.create(null);
        while (this.e()) {
          let attrName = this.r();
          if (!attrName) {
            break;
          }
          let attrValue = this.u() && this.J();
          if (attrValue === false) {
            throw this.a("Attribute value expected");
          }
          if (attrName in attributes) {
            throw this.a(`Duplicate attribute: ${attrName}`);
          }
          if (attrName === "xml:space" && attrValue !== "default" && attrValue !== "preserve") {
            throw this.a('Value of the `xml:space` attribute must be "default" or "preserve"');
          }
          attributes[attrName] = attrValue;
        }
        if (this.f.sortAttributes) {
          let attrNames = Object.keys(attributes).sort();
          let sortedAttributes = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < attrNames.length; ++i) {
            let attrName = attrNames[i];
            sortedAttributes[attrName] = attributes[attrName];
          }
          attributes = sortedAttributes;
        }
        return attributes;
      }
      /**
       * Consumes an `AttValue` (attribute value) if possible.
       *
       * @returns
       *   Contents of the `AttValue` minus quotes, or `false` if nothing was
       *   consumed. An empty string indicates that an `AttValue` was consumed but
       *   was empty.
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue
       */
      J() {
        let { c: scanner } = this;
        let quote = scanner.h();
        if (quote !== '"' && quote !== "'") {
          return false;
        }
        scanner.g();
        let chars;
        let isClosed = false;
        let value = emptyString2;
        let regex = quote === '"' ? attValueCharDoubleQuote : attValueCharSingleQuote;
        matchLoop:
          while (!scanner.z) {
            chars = scanner.G(regex);
            if (chars) {
              this.p(chars);
              value += chars.replace(attValueNormalizedWhitespace, " ");
            }
            switch (scanner.h()) {
              case quote:
                isClosed = true;
                break matchLoop;
              case "&":
                value += this.C();
                continue;
              case "<":
                throw this.a("Unescaped `<` is not allowed in an attribute value");
              case emptyString2:
                break matchLoop;
            }
          }
        if (!isClosed) {
          throw this.a("Unclosed attribute");
        }
        scanner.g();
        return value;
      }
      /**
       * Consumes a CDATA section if possible.
       *
       * @returns Whether a CDATA section was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect
       */
      K() {
        let { c: scanner } = this;
        let startIndex = scanner.d;
        if (!scanner.b("<![CDATA[")) {
          return false;
        }
        let text = scanner.t("]]>");
        this.p(text);
        if (!scanner.b("]]>")) {
          throw this.a("Unclosed CDATA section");
        }
        return this.f.preserveCdata ? this.j(new XmlCdata(normalizeLineBreaks(text)), startIndex) : this.x(text, startIndex);
      }
      /**
       * Consumes character data if possible.
       *
       * @returns Whether character data was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata
       */
      L() {
        let { c: scanner } = this;
        let startIndex = scanner.d;
        let charData = scanner.A(endCharData);
        if (!charData) {
          return false;
        }
        this.p(charData);
        if (scanner.h(3) === "]]>") {
          throw this.a("Element content may not contain the CDATA section close delimiter `]]>`");
        }
        return this.x(charData, startIndex);
      }
      /**
       * Consumes a comment if possible.
       *
       * @returns Whether a comment was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment
       */
      D() {
        let { c: scanner } = this;
        let startIndex = scanner.d;
        if (!scanner.b("<!--")) {
          return false;
        }
        let content = scanner.t("--");
        this.p(content);
        if (!scanner.b("-->")) {
          if (scanner.h(2) === "--") {
            throw this.a("The string `--` isn't allowed inside a comment");
          }
          throw this.a("Unclosed comment");
        }
        return this.f.preserveComments ? this.j(new XmlComment(normalizeLineBreaks(content)), startIndex) : true;
      }
      /**
       * Consumes a reference in a content context if possible.
       *
       * This differs from `consumeReference()` in that a consumed reference will be
       * added to the document as a text node instead of returned.
       *
       * @returns Whether a reference was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc
       */
      M() {
        let startIndex = this.c.d;
        let ref = this.C();
        return ref ? this.x(ref, startIndex) : false;
      }
      /**
       * Consumes a doctype declaration if possible.
       *
       * This is a loose implementation since doctype declarations are currently
       * discarded without further parsing.
       *
       * @returns Whether a doctype declaration was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd
       */
      N() {
        let { c: scanner } = this;
        let startIndex = scanner.d;
        if (!scanner.b("<!DOCTYPE")) {
          return false;
        }
        let name = this.e() && this.r();
        if (!name) {
          throw this.a("Expected a name");
        }
        let publicId;
        let systemId;
        if (this.e()) {
          if (scanner.b("PUBLIC")) {
            publicId = this.e() && this.O();
            if (publicId === false) {
              throw this.a("Expected a public identifier");
            }
            this.e();
          }
          if (publicId !== void 0 || scanner.b("SYSTEM")) {
            this.e();
            systemId = this.s();
            if (systemId === false) {
              throw this.a("Expected a system identifier");
            }
            this.e();
          }
        }
        let internalSubset;
        if (scanner.b("[")) {
          internalSubset = scanner.A(/\][\x20\t\r\n]*>/);
          if (!scanner.b("]")) {
            throw this.a("Unclosed internal subset");
          }
          this.e();
        }
        if (!scanner.b(">")) {
          throw this.a("Unclosed doctype declaration");
        }
        return this.f.preserveDocumentType ? this.j(new XmlDocumentType(name, publicId, systemId, internalSubset), startIndex) : true;
      }
      /**
       * Consumes an element if possible.
       *
       * @returns Whether an element was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element
       */
      B() {
        let { c: scanner } = this;
        let startIndex = scanner.d;
        if (!scanner.b("<")) {
          return false;
        }
        let name = this.r();
        if (!name) {
          scanner.o(startIndex);
          return false;
        }
        let attributes = this.I();
        let isEmpty = !!scanner.b("/>");
        let element = new XmlElement2(name, attributes);
        element.parent = this.l;
        if (!isEmpty) {
          if (!scanner.b(">")) {
            throw this.a(`Unclosed start tag for element \`${name}\``);
          }
          this.l = element;
          do {
            this.L();
          } while (this.B() || this.M() || this.K() || this.E() || this.D());
          let endTagMark = scanner.d;
          let endTagName;
          if (!scanner.b("</") || !(endTagName = this.r()) || endTagName !== name) {
            scanner.o(endTagMark);
            throw this.a(`Missing end tag for element ${name}`);
          }
          this.e();
          if (!scanner.b(">")) {
            throw this.a(`Unclosed end tag for element ${name}`);
          }
          this.l = element.parent;
        }
        return this.j(element, startIndex);
      }
      /**
       * Consumes an `Eq` production if possible.
       *
       * @returns Whether an `Eq` production was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq
       */
      u() {
        this.e();
        if (this.c.b("=")) {
          this.e();
          return true;
        }
        return false;
      }
      /**
       * Consumes `Misc` content if possible.
       *
       * @returns Whether anything was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc
       */
      w() {
        return this.D() || this.E() || this.e();
      }
      /**
       * Consumes one or more `Name` characters if possible.
       *
       * @returns `Name` characters, or an empty string if none were consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
       */
      r() {
        return isNameStartChar(this.c.h()) ? this.c.v(isNameChar) : emptyString2;
      }
      /**
       * Consumes a processing instruction if possible.
       *
       * @returns Whether a processing instruction was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi
       */
      E() {
        let { c: scanner } = this;
        let startIndex = scanner.d;
        if (!scanner.b("<?")) {
          return false;
        }
        let name = this.r();
        if (name) {
          if (name.toLowerCase() === "xml") {
            scanner.o(startIndex);
            throw this.a("XML declaration isn't allowed here");
          }
        } else {
          throw this.a("Invalid processing instruction");
        }
        if (!this.e()) {
          if (scanner.b("?>")) {
            return this.j(new XmlProcessingInstruction(name), startIndex);
          }
          throw this.a("Whitespace is required after a processing instruction name");
        }
        let content = scanner.t("?>");
        this.p(content);
        if (!scanner.b("?>")) {
          throw this.a("Unterminated processing instruction");
        }
        return this.j(new XmlProcessingInstruction(name, normalizeLineBreaks(content)), startIndex);
      }
      /**
       * Consumes a prolog if possible.
       *
       * @returns Whether a prolog was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd
       */
      H() {
        let { c: scanner } = this;
        let startIndex = scanner.d;
        this.P();
        while (this.w()) {
        }
        if (this.N()) {
          while (this.w()) {
          }
        }
        return startIndex < scanner.d;
      }
      /**
       * Consumes a public identifier literal if possible.
       *
       * @returns
       *   Value of the public identifier literal minus quotes, or `false` if
       *   nothing was consumed. An empty string indicates that a public id literal
       *   was consumed but was empty.
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-PubidLiteral
       */
      O() {
        let startIndex = this.c.d;
        let value = this.s();
        if (value !== false && !/^[-\x20\r\na-zA-Z0-9'()+,./:=?;!*#@$_%]*$/.test(value)) {
          this.c.o(startIndex);
          throw this.a("Invalid character in public identifier");
        }
        return value;
      }
      /**
       * Consumes a reference if possible.
       *
       * This differs from `consumeContentReference()` in that a consumed reference
       * will be returned rather than added to the document.
       *
       * @returns
       *   Parsed reference value, or `false` if nothing was consumed (to
       *   distinguish from a reference that resolves to an empty string).
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference
       */
      C() {
        let { c: scanner } = this;
        if (!scanner.b("&")) {
          return false;
        }
        let ref = scanner.v(isReferenceChar);
        if (scanner.F() !== ";") {
          throw this.a("Unterminated reference (a reference must end with `;`)");
        }
        let parsedValue;
        if (ref[0] === "#") {
          let codePoint = ref[1] === "x" ? parseInt(ref.slice(2), 16) : parseInt(ref.slice(1), 10);
          if (isNaN(codePoint)) {
            throw this.a("Invalid character reference");
          }
          if (!isXmlCodePoint(codePoint)) {
            throw this.a("Character reference resolves to an invalid character");
          }
          parsedValue = String.fromCodePoint(codePoint);
        } else {
          parsedValue = predefinedEntities[ref];
          if (parsedValue === void 0) {
            let {
              ignoreUndefinedEntities,
              resolveUndefinedEntity
            } = this.f;
            let wrappedRef = `&${ref};`;
            if (resolveUndefinedEntity) {
              let resolvedValue = resolveUndefinedEntity(wrappedRef);
              if (resolvedValue !== null && resolvedValue !== void 0) {
                let type = typeof resolvedValue;
                if (type !== "string") {
                  throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${type}`);
                }
                return resolvedValue;
              }
            }
            if (ignoreUndefinedEntities) {
              return wrappedRef;
            }
            scanner.o(-wrappedRef.length);
            throw this.a(`Named entity isn't defined: ${wrappedRef}`);
          }
        }
        return parsedValue;
      }
      /**
       * Consumes a `SystemLiteral` if possible.
       *
       * A `SystemLiteral` is similar to an attribute value, but allows the
       * characters `<` and `&` and doesn't replace references.
       *
       * @returns
       *   Value of the `SystemLiteral` minus quotes, or `false` if nothing was
       *   consumed. An empty string indicates that a `SystemLiteral` was consumed
       *   but was empty.
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral
       */
      s() {
        let { c: scanner } = this;
        let quote = scanner.b('"') || scanner.b("'");
        if (!quote) {
          return false;
        }
        let value = scanner.t(quote);
        this.p(value);
        if (!scanner.b(quote)) {
          throw this.a("Missing end quote");
        }
        return value;
      }
      /**
       * Consumes one or more whitespace characters if possible.
       *
       * @returns Whether any whitespace characters were consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white
       */
      e() {
        return !!this.c.v(isWhitespace);
      }
      /**
       * Consumes an XML declaration if possible.
       *
       * @returns Whether an XML declaration was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl
       */
      P() {
        let { c: scanner } = this;
        let startIndex = scanner.d;
        if (!scanner.b("<?xml")) {
          return false;
        }
        if (!this.e()) {
          throw this.a("Invalid XML declaration");
        }
        let version = !!scanner.b("version") && this.u() && this.s();
        if (version === false) {
          throw this.a("XML version is missing or invalid");
        } else if (!/^1\.[0-9]+$/.test(version)) {
          throw this.a("Invalid character in version number");
        }
        let encoding;
        let standalone;
        if (this.e()) {
          encoding = !!scanner.b("encoding") && this.u() && this.s();
          if (encoding) {
            this.e();
          }
          standalone = !!scanner.b("standalone") && this.u() && this.s();
          if (standalone) {
            if (standalone !== "yes" && standalone !== "no") {
              throw this.a('Only "yes" and "no" are permitted as values of `standalone`');
            }
            this.e();
          }
        }
        if (!scanner.b("?>")) {
          throw this.a("Invalid or unclosed XML declaration");
        }
        return this.f.preserveXmlDeclaration ? this.j(new XmlDeclaration(
          version,
          encoding || void 0,
          standalone || void 0
        ), startIndex) : true;
      }
      /**
       * Returns an `XmlError` for the current scanner position.
       */
      a(message) {
        let { c: scanner } = this;
        return new XmlError(message, scanner.d, scanner.m);
      }
      /**
       * Throws an invalid character error if any character in the given _string_
       * isn't a valid XML character.
       */
      p(string) {
        let { length } = string;
        for (let i = 0; i < length; ++i) {
          let cp = string.codePointAt(i);
          if (!isXmlCodePoint(cp)) {
            this.c.o(-([...string].length - i));
            throw this.a("Invalid character");
          }
          if (cp > 65535) {
            i += 1;
          }
        }
      }
    };
    function normalizeLineBreaks(text) {
      let i = 0;
      while ((i = text.indexOf("\r", i)) !== -1) {
        text = text[i + 1] === "\n" ? text.slice(0, i) + text.slice(i + 1) : text.slice(0, i) + "\n" + text.slice(i + 1);
      }
      return text;
    }
    function parseXml2(xml, options) {
      return new Parser(xml, options).document;
    }
  }
});

// node_modules/min-url/index.js
var require_min_url = __commonJS({
  "node_modules/min-url/index.js"(exports) {
    var qs = require_min_qs();
    var _ = require_min_util();
    exports.parse = function(url, parseQuery) {
      if ("string" != typeof url) {
        return url;
      }
      var ret = {}, arr, rest;
      ret.href = url;
      arr = split(url, "#");
      rest = arr[0];
      if (arr[1]) {
        ret.hash = "#" + arr[1];
      }
      arr = splicePattern(rest, /^[a-zA-Z][a-zA-Z0-9+-.]*:/);
      rest = arr[1];
      ret.protocol = arr[0].toLowerCase();
      arr = split(rest, "?");
      rest = arr[0];
      var query = arr[1];
      if (parseQuery) {
        query = qs.parse(query);
      }
      ret.query = query;
      if ("/" != rest.charAt(0)) {
        if (ret.schema) {
          ret.opaque = rest;
          return ret;
        }
      }
      if (_.startsWith(rest, "//")) {
        rest = rest.slice(2);
        arr = split(rest, "/");
        ret.pathname = "/" + unescape(arr[1] || "");
        arr = parseAuthority(arr[0]);
        ret.auth = arr[0];
        var host = arr[1];
        arr = split(host, ":");
        ret.hostname = arr[0];
        ret.port = ~~arr[1];
      }
      return ret;
    };
    var slashProtocols = "http https ftp gopher file".split(" ");
    exports.format = function(obj) {
      if (!obj || "object" != typeof obj)
        return obj;
      var protocol = obj.protocol;
      var arr = [protocol];
      if (!protocol || _.includes(slashProtocols, protocol.slice(0, protocol.length - 1))) {
        arr.push("//");
      }
      if (obj.auth) {
        arr.push(obj.auth, "@");
      }
      arr.push(obj.hostname);
      if (obj.port) {
        arr.push(":", obj.port);
      }
      arr.push(obj.pathname);
      var query = obj.query;
      if (query) {
        if ("string" != typeof query) {
          query = qs.stringify(query);
        }
        if (query) {
          arr.push("?", query);
        }
      }
      arr.push(obj.hash);
      var ret = [];
      for (var i = 0; i < arr.length; i++) {
        if (arr[i])
          ret.push(arr[i]);
      }
      return ret.join("");
    };
    exports.appendQuery = function(url, query) {
      var arr = split(url, "#");
      url = arr[0];
      var fragment = arr[1];
      if (_.isObject(query)) {
        query = qs.stringify(query);
      }
      if (_.includes(url, "?")) {
        if (!_.endsWith(url, "&") && !_.endsWith(url, "?")) {
          if (query) {
            query = "&" + query;
          }
        }
      } else {
        if (query) {
          query = "?" + query;
        }
      }
      if (query) {
        url += query;
      }
      if (fragment) {
        url += "#" + fragment;
      }
      return url;
    };
    function splicePattern(str, reg) {
      var ret = "";
      str = str.replace(reg, function(matched) {
        ret = matched;
        return "";
      });
      return [ret, str];
    }
    function split(str, sep) {
      var arr = [];
      var index = _.indexOf(str, sep);
      if (-1 == index) {
        arr[0] = str;
      } else {
        arr[0] = str.slice(0, index);
        arr[1] = str.slice(index + sep.length);
      }
      return arr;
    }
    function parseAuthority(authAndHost) {
      var arr = split(authAndHost, "@");
      var auth = arr[0];
      var host = arr[1];
      if (!host) {
        host = arr[0];
        auth = null;
      }
      return [auth, host];
    }
  }
});

// src/auth/api_key.ts
var APIKeyAuth = class {
  constructor(apiKey) {
    this.apiKey = apiKey;
    if (typeof apiKey === "undefined") {
      throw new Error("apiKey must be provided");
    }
  }
  async sign(method, url, params) {
    params.set("api_key", await this.getAPIKey());
  }
  async getAPIKey() {
    return typeof this.apiKey === "string" ? this.apiKey : await this.apiKey();
  }
};

// src/oauth-browser.ts
var OAuth = () => {
  throw new Error("OAuth is not supported in the browser");
};

// src/auth/oauth.ts
var OAuthAuth = class {
  constructor(consumerKey, consumerSecret, oauthToken, oauthTokenSecret) {
    this.oauthToken = oauthToken;
    this.oauthTokenSecret = oauthTokenSecret;
    this.oauth = new OAuth(consumerKey, consumerSecret);
    if (typeof oauthToken !== "string" && oauthToken !== false) {
      throw new Error('Missing required argument "oauthToken"');
    }
    if (typeof oauthTokenSecret !== "string" && oauthTokenSecret !== false) {
      throw new Error('Missing required argument "oauthTokenSecret"');
    }
    if (typeof oauthToken === "string" && typeof oauthTokenSecret !== "string") {
      throw new Error(
        'if "oauthToken" is specified, "oauthTokenSecret" must also be specified'
      );
    }
  }
  async sign(method, url, params) {
    for (const [key, value] of Object.entries(this.oauth.params())) {
      params.set(key, value);
    }
    if (this.oauthToken !== false) {
      params.set("oauth_token", this.oauthToken);
    }
    params.set(
      "oauth_signature",
      this.signature(method, url, Object.fromEntries(params.entries()))
    );
  }
  signature(method, url, params) {
    return this.oauthTokenSecret === false ? this.oauth.signature(method, url, params) : this.oauth.signature(method, url, params, this.oauthTokenSecret);
  }
  static isOAuthConfig(config) {
    return typeof config === "object" && typeof config.consumerKey === "string" && typeof config.consumerSecret === "string" && (typeof config.oauthToken === "string" || config.oauthToken === false) && (typeof config.oauthTokenSecret === "string" || config.oauthTokenSecret === false);
  }
};

// src/services/rest/api.ts
var POST_REGEXP = /(^flickr.(g(alleries.(addPhoto$|create$|edit(Meta$|Photo($|s$))|removePhoto$)|roups.(discuss.(replies.(add$|delete$|edit$)|topics.add$)|join($|Request$)|leave$|pools.(add$|remove$)))|blogs.postPhoto$|favorites.(add$|remove$)|photos(.(s(et(ContentType$|Dates$|Meta$|Perms$|SafetyLevel$|Tags$)|uggestions.(approveSuggestion$|re(jectSuggestion$|moveSuggestion$)|suggestLocation$))|addTags$|comments.(addComment$|deleteComment$|editComment$)|delete$|geo.(batchCorrectLocation$|correctLocation$|removeLocation$|set(Context$|Location$|Perms$))|licenses.setLicense$|notes.(add$|delete$|edit$)|people.(add$|delete($|Coords$)|editCoords$)|removeTag$|transform.rotate$)|ets.(c(omments.(addComment$|deleteComment$|editComment$)|reate$)|addPhoto$|delete$|edit(Meta$|Photos$)|orderSets$|re(movePhoto($|s$)|orderPhotos$)|setPrimaryPhoto$))|testimonials.(a(ddTestimonial$|pproveTestimonial$)|deleteTestimonial$|editTestimonial$)))/;

// src/params.ts
var GET = class {
  constructor() {
    this.searchParams = new URLSearchParams();
  }
  set(key, value) {
    this.searchParams.set(key, value);
  }
  *entries() {
    for (const [key, value] of this.searchParams.entries()) {
      yield [key, value];
    }
  }
};
var POST = class {
  constructor() {
    this.formData = new FormData();
  }
  set(key, value) {
    this.formData.set(key, value);
  }
  getFormData() {
    return this.formData;
  }
  *entries() {
    for (const [key, value] of this.formData.entries()) {
      yield [key, value.toString()];
    }
  }
};

// src/parser/json.ts
var JSONParser = class {
  parse(res) {
    return res.json();
  }
};

// src/services/rest/index.ts
var FlickrService = class {
  constructor(transport, auth) {
    this.transport = transport;
    this.auth = auth;
  }
  async call(method, params) {
    const url = "https://api.flickr.com/services/rest";
    const httpMethod = this.getHTTPMethod(method);
    const payload = httpMethod === "POST" ? new POST() : new GET();
    for (const [key, value] of Object.entries(params)) {
      payload.set(key, value);
    }
    payload.set("method", method);
    payload.set("format", "json");
    payload.set("nojsoncallback", "1");
    await this.auth.sign(httpMethod, url, payload);
    const res = payload instanceof POST ? await this.transport.post(url, payload) : await this.transport.get(url, payload);
    const parser = new JSONParser();
    const json = await parser.parse(res);
    if (json.stat === "fail") {
      throw new Error(json.message, {
        cause: res
      });
    }
    return json;
  }
  getHTTPMethod(method) {
    return POST_REGEXP.test(method) ? "POST" : "GET";
  }
};

// src/shims/querystring-browser.ts
var import_min_qs = __toESM(require_min_qs());

// src/parser/form.ts
var FormParser = class {
  async parse(res) {
    return (0, import_min_qs.parse)(await res.text());
  }
};

// src/services/oauth.ts
var OAuthService = class {
  constructor(transport, auth) {
    this.transport = transport;
    this.auth = auth;
  }
  async request(callbackUrl) {
    const url = "https://www.flickr.com/services/oauth/request_token";
    const params = new GET();
    params.set("oauth_callback", callbackUrl);
    await this.auth.sign("GET", url, params);
    const res = await this.transport.get(url, params);
    const parser = new FormParser();
    const { oauth_token, oauth_token_secret } = await parser.parse(res);
    return {
      requestToken: oauth_token,
      requestTokenSecret: oauth_token_secret
    };
  }
  async verify(oauthVerifier) {
    const url = "https://www.flickr.com/services/oauth/access_token";
    const params = new GET();
    params.set("oauth_verifier", oauthVerifier);
    await this.auth.sign("GET", url, params);
    const res = await this.transport.get(url, params);
    const parser = new FormParser();
    const { user_nsid, oauth_token, oauth_token_secret } = await parser.parse(res);
    return {
      nsid: user_nsid,
      oauthToken: oauth_token,
      oauthTokenSecret: oauth_token_secret
    };
  }
  // this should return a string ready to be dropped into a location header
  authorizeUrl(requestToken, perms = "read") {
    switch (perms) {
      case "read":
      case "write":
      case "delete":
        const url = new URL("https://www.flickr.com/services/oauth/authorize");
        url.searchParams.set("perms", perms);
        url.searchParams.set("oauth_token", requestToken);
        return url.href;
      default:
        throw new Error('Unknown oauth perms "' + perms + '"');
    }
  }
};

// src/shims/fs-promises-browser.ts
function readFile() {
  throw new Error("Reading from file is unsupported in the browser");
}

// src/parser/xml.ts
var import_parse_xml = __toESM(require_browser());
function isXmlElement(node) {
  return node.type === import_parse_xml.XmlNode.TYPE_ELEMENT;
}
function isXmlText(node) {
  return node.type === import_parse_xml.XmlNode.TYPE_TEXT;
}
var XMLParser = class {
  async parse(res) {
    const xml = await res.text();
    const ast = (0, import_parse_xml.parseXml)(this.clean(xml));
    const { rsp } = this.jsify(ast.children[0]);
    return rsp;
  }
  clean(xml) {
    return xml.replace(/^<\?xml.*\?>/, "");
  }
  jsify(node) {
    if (Array.isArray(node)) {
      return node.reduce((memo, n) => ({ ...memo, ...this.jsify(n) }), {});
    }
    if (isXmlElement(node)) {
      return {
        [node.name]: {
          ...node.attributes,
          ...this.jsify(node.children)
        }
      };
    }
    if (isXmlText(node)) {
      if (node.text.trim() === "") {
        return {};
      }
      return {
        _content: node.text
      };
    }
    return {};
  }
};

// src/services/upload.ts
var UploadService = class {
  constructor(transport, auth) {
    this.transport = transport;
    this.auth = auth;
  }
  async upload(file, params = {}) {
    const url = "https://up.flickr.com/services/upload";
    const payload = new POST();
    for (const [key, value] of Object.entries(params)) {
      payload.set(key, value);
    }
    await this.auth.sign("POST", url, payload);
    payload.set("photo", await this.getBlob(file));
    const res = await this.transport.post(url, payload);
    const parser = new XMLParser();
    const rsp = await parser.parse(res);
    if (rsp.stat !== "ok") {
      throw new Error(rsp.err.msg, {
        cause: res
      });
    }
    return {
      id: rsp.photoid._content,
      secret: rsp.photoid.secret,
      originalsecret: rsp.photoid.originalsecret
    };
  }
  async getBlob(file) {
    if (typeof window === "undefined" && typeof file === "string") {
      return new File([await readFile(file)], file);
    } else {
      return file;
    }
  }
};

// src/services/replace.ts
var ReplaceService = class {
  constructor(transport, auth) {
    this.transport = transport;
    this.auth = auth;
  }
  async replace(id, file) {
    const url = "https://up.flickr.com/services/replace";
    const payload = new POST();
    payload.set("photo_id", id);
    await this.auth.sign("POST", url, payload);
    payload.set("photo", await this.getBlob(file));
    const res = await this.transport.post(url, payload);
    const parser = new XMLParser();
    const rsp = await parser.parse(res);
    if (rsp.stat !== "ok") {
      throw new Error(rsp.err.msg, {
        cause: res
      });
    }
    return {
      id: rsp.photoid._content,
      secret: rsp.photoid.secret,
      originalsecret: rsp.photoid.originalsecret
    };
  }
  async getBlob(file) {
    if (typeof file === "string") {
      return new File([await readFile(file)], file);
    } else {
      return file;
    }
  }
};

// src/shims/url-browser.ts
var import_min_url = __toESM(require_min_url());

// src/transport/fetch.ts
var FetchTransport = class {
  constructor(init = {}) {
    this.init = init;
  }
  async fetch(url, init) {
    const res = await fetch(url, init);
    if (!res.ok) {
      throw new Error(res.statusText, {
        cause: res
      });
    }
    return res;
  }
  async get(url, params = new GET()) {
    const { query, ...parsed } = (0, import_min_url.parse)(url, true);
    const urlWithQueryParams = (0, import_min_url.format)({
      ...parsed,
      query: {
        ...query,
        ...Object.fromEntries(params.entries())
      }
    });
    const init = {
      ...this.init,
      method: "GET"
    };
    return this.fetch(urlWithQueryParams, init);
  }
  async post(url, params = new POST()) {
    const body = params.getFormData();
    const init = {
      ...this.init,
      method: "POST",
      body
    };
    return this.fetch(url, init);
  }
};

// src/auth/null.ts
var NullAuth = class {
  async sign() {
  }
};

// src/transport/mock.ts
var MockTransport = class {
  constructor(response) {
    this.response = typeof response === "string" ? response : JSON.stringify(response);
  }
  async get() {
    return new Response(this.response);
  }
  async post() {
    return new Response(this.response);
  }
};

// src/index.ts
function createFlickr(auth, transport = new FetchTransport()) {
  if (!auth) {
    throw new Error("Invalid auth config");
  }
  if (typeof auth === "string") {
    return createFlickr(new APIKeyAuth(auth), transport);
  }
  if (OAuthAuth.isOAuthConfig(auth)) {
    return createFlickr(
      new OAuthAuth(
        auth.consumerKey,
        auth.consumerSecret,
        auth.oauthToken,
        auth.oauthTokenSecret
      ),
      transport
    );
  }
  const flickr = async (method, params) => {
    const service = new FlickrService(transport, auth);
    return service.call(method, params);
  };
  const upload = async (file, params) => {
    const service = new UploadService(transport, auth);
    return service.upload(file, params);
  };
  const replace = async (id, file) => {
    const service = new ReplaceService(transport, auth);
    return service.replace(id, file);
  };
  if (auth instanceof OAuthAuth) {
    const oauth = new OAuthService(transport, auth);
    return {
      flickr,
      upload,
      replace,
      // oauth is only defined if the auth method is oauth
      oauth
    };
  } else {
    return { flickr, upload, replace };
  }
}
export {
  APIKeyAuth,
  FetchTransport,
  FlickrService,
  FormParser,
  GET,
  JSONParser,
  MockTransport,
  NullAuth,
  OAuth,
  OAuthAuth,
  OAuthService,
  POST,
  POST_REGEXP,
  ReplaceService,
  UploadService,
  XMLParser,
  createFlickr
};
/*! Bundled license information:

@rgrove/parse-xml/dist/browser.js:
  (*! @rgrove/parse-xml v4.1.0 | ISC License | Copyright Ryan Grove *)
*/
